const { createServer } = require('http');
const { parse } = require('url');
const next = require('next');
const { Server } = require('socket.io');
const connectDB = require('./config/database');
const { authenticate, generateToken } = require('./middleware/auth');

// Import models
const User = require('./models/User');
const Invite = require('./models/Invite');
const Chat = require('./models/Chat');
const Message = require('./models/Message');

const dev = process.env.NODE_ENV !== 'production';
const hostname = 'localhost';
const port = 3000;

// Connect to MongoDB
connectDB();

// Prepare Next.js app
const app = next({ dev, hostname, port });
const handle = app.getRequestHandler();

// Store for active socket connections
const activeConnections = new Map(); // userId -> socketId

app.prepare().then(() => {
  const httpServer = createServer(async (req, res) => {
    try {
      const parsedUrl = parse(req.url, true);
      
      // Handle API routes
      if (req.url.startsWith('/api/auth/')) {
        await handleAuthAPI(req, res);
      } else {
        await handle(req, res, parsedUrl);
      }
    } catch (err) {
      console.error('Error occurred handling', req.url, err);
      res.statusCode = 500;
      res.end('internal server error');
    }
  });

  // Auth API handler
  const handleAuthAPI = async (req, res) => {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const pathname = url.pathname;

    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

    if (req.method === 'OPTIONS') {
      res.statusCode = 200;
      res.end();
      return;
    }

    if (pathname === '/api/auth/register' && req.method === 'POST') {
      let body = '';
      req.on('data', chunk => body += chunk.toString());
      req.on('end', async () => {
        try {
          const { username, password } = JSON.parse(body);

          if (!username || !password) {
            res.statusCode = 400;
            res.end(JSON.stringify({ error: 'Username and password are required' }));
            return;
          }

          if (username.length < 2 || username.length > 20) {
            res.statusCode = 400;
            res.end(JSON.stringify({ error: 'Username must be between 2 and 20 characters' }));
            return;
          }

          if (password.length < 6) {
            res.statusCode = 400;
            res.end(JSON.stringify({ error: 'Password must be at least 6 characters' }));
            return;
          }

          const existingUser = await User.findOne({ username });
          if (existingUser) {
            res.statusCode = 400;
            res.end(JSON.stringify({ error: 'Username already exists' }));
            return;
          }

          const user = new User({ username, password });
          await user.save();

          const token = generateToken(user._id);

          res.statusCode = 201;
          res.end(JSON.stringify({
            message: 'User created successfully',
            token,
            user: { id: user._id, username: user.username }
          }));
        } catch (error) {
          console.error('Registration error:', error);
          res.statusCode = 500;
          res.end(JSON.stringify({ error: 'Server error' }));
        }
      });
    } else if (pathname === '/api/auth/login' && req.method === 'POST') {
      let body = '';
      req.on('data', chunk => body += chunk.toString());
      req.on('end', async () => {
        try {
          const { username, password } = JSON.parse(body);

          if (!username || !password) {
            res.statusCode = 400;
            res.end(JSON.stringify({ error: 'Username and password are required' }));
            return;
          }

          const user = await User.findOne({ username });
          if (!user) {
            res.statusCode = 401;
            res.end(JSON.stringify({ error: 'Invalid credentials' }));
            return;
          }

          const isPasswordValid = await user.comparePassword(password);
          if (!isPasswordValid) {
            res.statusCode = 401;
            res.end(JSON.stringify({ error: 'Invalid credentials' }));
            return;
          }

          const token = generateToken(user._id);

          // Update user online status
          user.isOnline = true;
          user.lastSeen = new Date();
          await user.save();

          res.statusCode = 200;
          res.end(JSON.stringify({
            message: 'Login successful',
            token,
            user: { id: user._id, username: user.username }
          }));
        } catch (error) {
          console.error('Login error:', error);
          res.statusCode = 500;
          res.end(JSON.stringify({ error: 'Server error' }));
        }
      });
    } else {
      res.statusCode = 404;
      res.end(JSON.stringify({ error: 'Not found' }));
    }
  };

  const io = new Server(httpServer, {
    cors: {
      origin: "*",
      methods: ["GET", "POST"]
    }
  });

  // Apply authentication middleware
  io.use(authenticate);

  io.on('connection', async (socket) => {
    console.log('User connected:', socket.username, socket.id);

    try {
      // Update user online status and socket ID
      await User.findByIdAndUpdate(socket.userId, {
        isOnline: true,
        socketId: socket.id,
        lastSeen: new Date()
      });

      // Store active connection
      activeConnections.set(socket.userId.toString(), socket.id);

      // Send user's pending invites
      const pendingInvites = await Invite.find({
        to: socket.userId,
        status: 'pending'
      }).populate('from', 'username');

      socket.emit('pending-invites', pendingInvites.map(invite => ({
        id: invite._id,
        from: invite.fromUsername,
        to: invite.toUsername,
        status: invite.status,
        timestamp: invite.createdAt,
        message: invite.message
      })));

      // Send user's active chats
      const activeChats = await Chat.find({
        participants: socket.userId,
        isActive: true
      }).populate('participants', 'username');

      socket.emit('active-chats', activeChats.map(chat => {
        const otherUser = chat.participants.find(p => p._id.toString() !== socket.userId.toString());
        return {
          chatId: chat.chatId,
          otherUser: otherUser.username,
          lastMessage: chat.lastMessage,
          createdAt: chat.createdAt
        };
      }));

      // Send list of online users
      const onlineUsers = await User.find({
        isOnline: true,
        _id: { $ne: socket.userId }
      }).select('username');

      socket.emit('online-users', onlineUsers.map(user => ({
        username: user.username,
        status: 'online'
      })));

      // Notify others about new user
      socket.broadcast.emit('user-joined', {
        username: socket.username,
        status: 'online'
      });

    } catch (error) {
      console.error('Connection setup error:', error);
      socket.emit('error', 'Connection setup failed');
    }

    // Handle user search
    socket.on('search-users', async (searchTerm) => {
      try {
        const users = await User.find({
          username: { $regex: searchTerm, $options: 'i' },
          _id: { $ne: socket.userId },
          isOnline: true
        }).select('username').limit(10);

        socket.emit('search-results', users.map(user => ({
          username: user.username,
          status: 'online'
        })));
      } catch (error) {
        console.error('Search error:', error);
        socket.emit('error', 'Search failed');
      }
    });

    // Handle invite sending
    socket.on('send-invite', async (data) => {
      try {
        const { toUsername, message = '' } = data;
        
        const toUser = await User.findOne({ username: toUsername });
        if (!toUser) {
          socket.emit('invite-error', 'User not found');
          return;
        }

        if (toUser._id.toString() === socket.userId.toString()) {
          socket.emit('invite-error', 'Cannot invite yourself');
          return;
        }

        // Check if invite already exists
        const existingInvite = await Invite.findOne({
          from: socket.userId,
          to: toUser._id,
          status: 'pending'
        });

        if (existingInvite) {
          socket.emit('invite-error', 'Invite already sent');
          return;
        }

        // Check if chat already exists
        const existingChat = await Chat.findOne({
          participants: { $all: [socket.userId, toUser._id] },
          isActive: true
        });

        if (existingChat) {
          socket.emit('invite-error', 'Chat already exists with this user');
          return;
        }

        const invite = new Invite({
          from: socket.userId,
          fromUsername: socket.username,
          to: toUser._id,
          toUsername: toUsername,
          message
        });

        await invite.save();

        // Send invite to receiver if online
        const receiverSocketId = activeConnections.get(toUser._id.toString());
        if (receiverSocketId) {
          io.to(receiverSocketId).emit('new-invite', {
            id: invite._id,
            from: invite.fromUsername,
            to: invite.toUsername,
            status: invite.status,
            timestamp: invite.createdAt,
            message: invite.message
          });
        }

        socket.emit('invite-sent', { toUsername });
      } catch (error) {
        console.error('Send invite error:', error);
        socket.emit('invite-error', 'Failed to send invite');
      }
    });

    // Handle invite response
    socket.on('respond-invite', async (data) => {
      try {
        const { inviteId, response } = data;
        
        const invite = await Invite.findById(inviteId);
        if (!invite) {
          socket.emit('error', 'Invite not found');
          return;
        }

        if (invite.to.toString() !== socket.userId.toString()) {
          socket.emit('error', 'Unauthorized');
          return;
        }

        invite.status = response;
        await invite.save();

        if (response === 'accept') {
          // Create chat room
          const chatId = `${invite.fromUsername}-${invite.toUsername}-${Date.now()}`;
          
          const chat = new Chat({
            participants: [invite.from, invite.to],
            participantUsernames: [invite.fromUsername, invite.toUsername],
            chatId
          });

          await chat.save();

          // Notify both users
          const senderSocketId = activeConnections.get(invite.from.toString());
          if (senderSocketId) {
            io.to(senderSocketId).emit('invite-accepted', {
              username: invite.toUsername,
              chatId
            });
          }

          socket.emit('invite-accepted', {
            username: invite.fromUsername,
            chatId
          });
        } else {
          // Notify sender of rejection
          const senderSocketId = activeConnections.get(invite.from.toString());
          if (senderSocketId) {
            io.to(senderSocketId).emit('invite-rejected', {
              username: invite.toUsername
            });
          }
        }
      } catch (error) {
        console.error('Respond invite error:', error);
        socket.emit('error', 'Failed to respond to invite');
      }
    });

    // Handle sending messages
    socket.on('send-message', async (data) => {
      try {
        const { chatId, message } = data;
        
        const chat = await Chat.findOne({ chatId });
        if (!chat) {
          socket.emit('error', 'Chat not found');
          return;
        }

        // Verify user is part of this chat
        if (!chat.participants.includes(socket.userId)) {
          socket.emit('error', 'Unauthorized');
          return;
        }

        const messageObj = new Message({
          chatId,
          sender: socket.userId,
          senderUsername: socket.username,
          content: message
        });

        await messageObj.save();

        // Update chat's last message
        chat.lastMessage = {
          content: message,
          sender: socket.username,
          timestamp: messageObj.createdAt
        };
        await chat.save();

        const messageData = {
          id: messageObj._id,
          sender: socket.username,
          content: message,
          timestamp: messageObj.createdAt
        };

        // Send to the other user
        const otherUserId = chat.participants.find(p => p.toString() !== socket.userId.toString());
        const otherSocketId = activeConnections.get(otherUserId.toString());

        if (otherSocketId) {
          io.to(otherSocketId).emit('new-message', {
            chatId,
            message: messageData
          });
        }

        // Confirm to sender
        socket.emit('message-sent', {
          chatId,
          message: messageData
        });
      } catch (error) {
        console.error('Send message error:', error);
        socket.emit('error', 'Failed to send message');
      }
    });

    // Handle getting chat history
    socket.on('get-chat-history', async (chatId) => {
      try {
        const chat = await Chat.findOne({ chatId });
        if (!chat || !chat.participants.includes(socket.userId)) {
          socket.emit('error', 'Unauthorized or chat not found');
          return;
        }

        const messages = await Message.find({ chatId })
          .sort({ createdAt: 1 })
          .limit(100)
          .select('senderUsername content createdAt');

        socket.emit('chat-history', {
          chatId,
          messages: messages.map(msg => ({
            id: msg._id,
            sender: msg.senderUsername,
            content: msg.content,
            timestamp: msg.createdAt
          }))
        });
      } catch (error) {
        console.error('Get chat history error:', error);
        socket.emit('error', 'Failed to get chat history');
      }
    });

    // Handle disconnection
    socket.on('disconnect', async () => {
      try {
        console.log('User disconnected:', socket.username);
        
        // Update user offline status
        await User.findByIdAndUpdate(socket.userId, {
          isOnline: false,
          socketId: null,
          lastSeen: new Date()
        });

        // Remove from active connections
        activeConnections.delete(socket.userId.toString());
        
        // Notify others
        socket.broadcast.emit('user-left', { username: socket.username });
      } catch (error) {
        console.error('Disconnect error:', error);
      }
    });

    // Handle user search
    socket.on('search-users', (searchTerm) => {
      const currentUser = connectedUsers.get(socket.id);
      if (!currentUser) return;

      const results = Array.from(connectedUsers.values())
        .filter(user => 
          user.username !== currentUser.username &&
          user.username.toLowerCase().includes(searchTerm.toLowerCase())
        )
        .map(user => ({ username: user.username, status: user.status }));

      socket.emit('search-results', results);
    });

    // Handle invite sending
    socket.on('send-invite', (data) => {
      const { toUsername } = data;
      const fromUser = connectedUsers.get(socket.id);
      
      if (!fromUser) return;

      const toSocketId = usernames.get(toUsername);
      if (!toSocketId) {
        socket.emit('invite-error', 'User not found or offline');
        return;
      }

      const inviteId = `${fromUser.username}-${toUsername}-${Date.now()}`;
      const invite = {
        id: inviteId,
        from: fromUser.username,
        to: toUsername,
        status: 'pending',
        timestamp: new Date().toISOString()
      };

      invites.set(inviteId, invite);

      // Send invite to receiver
      io.to(toSocketId).emit('new-invite', invite);
      
      // Confirm to sender
      socket.emit('invite-sent', { toUsername });
    });

    // Handle invite response
    socket.on('respond-invite', (data) => {
      const { inviteId, response } = data; // response: 'accept' or 'reject'
      const invite = invites.get(inviteId);
      
      if (!invite) return;

      const fromSocketId = usernames.get(invite.from);
      const currentUser = connectedUsers.get(socket.id);

      if (!currentUser || currentUser.username !== invite.to) return;

      invite.status = response;
      
      if (response === 'accept') {
        // Create chat room
        const chatId = `${invite.from}-${invite.to}`;
        activeChats.set(chatId, {
          user1: invite.from,
          user2: invite.to,
          messages: [],
          createdAt: new Date().toISOString()
        });

        // Notify both users
        if (fromSocketId) {
          io.to(fromSocketId).emit('invite-accepted', {
            username: invite.to,
            chatId
          });
        }
        
        socket.emit('invite-accepted', {
          username: invite.from,
          chatId
        });
      } else {
        // Notify sender of rejection
        if (fromSocketId) {
          io.to(fromSocketId).emit('invite-rejected', {
            username: invite.to
          });
        }
      }

      // Remove the invite
      invites.delete(inviteId);
    });

    // Handle getting pending invites
    socket.on('get-pending-invites', () => {
      const currentUser = connectedUsers.get(socket.id);
      if (!currentUser) return;

      const pendingInvites = Array.from(invites.values())
        .filter(invite => invite.to === currentUser.username && invite.status === 'pending');

      socket.emit('pending-invites', pendingInvites);
    });

    // Handle sending messages
    socket.on('send-message', (data) => {
      const { chatId, message } = data;
      const currentUser = connectedUsers.get(socket.id);
      
      if (!currentUser) return;

      const chat = activeChats.get(chatId);
      if (!chat) return;

      // Verify user is part of this chat
      if (chat.user1 !== currentUser.username && chat.user2 !== currentUser.username) {
        return;
      }

      const messageObj = {
        id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        sender: currentUser.username,
        content: message,
        timestamp: new Date().toISOString()
      };

      chat.messages.push(messageObj);

      // Send to the other user
      const otherUsername = chat.user1 === currentUser.username ? chat.user2 : chat.user1;
      const otherSocketId = usernames.get(otherUsername);

      if (otherSocketId) {
        io.to(otherSocketId).emit('new-message', {
          chatId,
          message: messageObj
        });
      }

      // Confirm to sender
      socket.emit('message-sent', {
        chatId,
        message: messageObj
      });
    });

    // Handle getting chat history
    socket.on('get-chat-history', (chatId) => {
      const currentUser = connectedUsers.get(socket.id);
      if (!currentUser) return;

      const chat = activeChats.get(chatId);
      if (!chat) return;

      // Verify user is part of this chat
      if (chat.user1 !== currentUser.username && chat.user2 !== currentUser.username) {
        return;
      }

      socket.emit('chat-history', {
        chatId,
        messages: chat.messages
      });
    });

    // Handle getting active chats
    socket.on('get-active-chats', () => {
      const currentUser = connectedUsers.get(socket.id);
      if (!currentUser) return;

      const userChats = Array.from(activeChats.entries())
        .filter(([chatId, chat]) => 
          chat.user1 === currentUser.username || chat.user2 === currentUser.username
        )
        .map(([chatId, chat]) => ({
          chatId,
          otherUser: chat.user1 === currentUser.username ? chat.user2 : chat.user1,
          lastMessage: chat.messages[chat.messages.length - 1] || null,
          createdAt: chat.createdAt
        }));

      socket.emit('active-chats', userChats);
    });

    // Handle disconnection
    socket.on('disconnect', () => {
      const user = connectedUsers.get(socket.id);
      if (user) {
        console.log('User disconnected:', user.username);
        
        // Remove from maps
        connectedUsers.delete(socket.id);
        usernames.delete(user.username);
        
        // Notify others
        socket.broadcast.emit('user-left', { username: user.username });
        
        // Clean up pending invites
        const userInvites = Array.from(invites.entries())
          .filter(([id, invite]) => invite.from === user.username || invite.to === user.username);
        
        userInvites.forEach(([id]) => invites.delete(id));
      }
    });
  });

  httpServer
    .once('error', (err) => {
      console.error(err);
      process.exit(1);
    })
    .listen(port, () => {
      console.log(`> Ready on http://${hostname}:${port}`);
    });
});
